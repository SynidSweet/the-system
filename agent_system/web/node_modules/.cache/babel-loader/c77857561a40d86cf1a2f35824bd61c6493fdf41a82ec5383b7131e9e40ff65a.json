{"ast":null,"code":"import _objectSpread from \"/code/personal/the-system/agent_system/web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _extends from '@babel/runtime/helpers/extends';\nimport React, { useState, useEffect } from 'react';\nimport Container from './container.js';\nfunction Animated(props) {\n  const initialX = props.nodes[0].x;\n  const initialY = props.nodes[0].y;\n  const [state, setState] = useState({\n    nodes: props.nodes.map(n => _objectSpread(_objectSpread({}, n), {}, {\n      x: initialX,\n      y: initialY\n    })),\n    links: props.links.map(l => ({\n      source: _objectSpread(_objectSpread({}, l.source), {}, {\n        x: initialX,\n        y: initialY\n      }),\n      target: _objectSpread(_objectSpread({}, l.target), {}, {\n        x: initialX,\n        y: initialY\n      })\n    }))\n  });\n  const [animation, setAnimation] = useState(null);\n  useEffect(animate, [props.nodes, props.links]);\n  function animate() {\n    // Stop previous animation if one is already in progress.  We will start the next animation\n    // from the position we are currently in\n    clearInterval(animation);\n    let counter = 0;\n\n    // Do as much one-time calculation outside of the animation step, which needs to be fast\n    const animationContext = getAnimationContext(state, props);\n    const interval = setInterval(() => {\n      counter++;\n      if (counter === props.steps) {\n        clearInterval(interval);\n        setState({\n          nodes: props.nodes,\n          links: props.links\n        });\n        return;\n      }\n      setState(calculateNewState(animationContext, counter / props.steps));\n    }, props.duration / props.steps);\n    setAnimation(interval);\n    return () => clearInterval(animation);\n  }\n  function getAnimationContext(initialState, newState) {\n    // Nodes/links that are in both states need to be moved from the old position to the new one\n    // Nodes/links only in the initial state are being removed, and should be moved to the position\n    // of the closest ancestor that still exists, or the new root\n    // Nodes/links only in the new state are being added, and should be moved from the position of\n    // the closest ancestor that previously existed, or the old root\n\n    // The base determines which node/link the data (like classes and labels) comes from for rendering\n\n    // We only run this once at the start of the animation, so optimisation is less important\n    const addedNodes = newState.nodes.filter(n1 => initialState.nodes.every(n2 => !areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: getClosestAncestor(n1, newState, initialState),\n      new: n1\n    }));\n    const changedNodes = newState.nodes.filter(n1 => initialState.nodes.some(n2 => areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: initialState.nodes.find(n2 => areNodesSame(n1, n2)),\n      new: n1\n    }));\n    const removedNodes = initialState.nodes.filter(n1 => newState.nodes.every(n2 => !areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: n1,\n      new: getClosestAncestor(n1, initialState, newState)\n    }));\n    const addedLinks = newState.links.filter(l1 => initialState.links.every(l2 => !areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: getClosestAncestor(l1.target, newState, initialState),\n      new: l1\n    }));\n    const changedLinks = newState.links.filter(l1 => initialState.links.some(l2 => areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: initialState.links.find(l2 => areLinksSame(l1, l2)),\n      new: l1\n    }));\n    const removedLinks = initialState.links.filter(l1 => newState.links.every(l2 => !areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: l1,\n      new: getClosestAncestor(l1.target, initialState, newState)\n    }));\n    return {\n      nodes: changedNodes.concat(addedNodes).concat(removedNodes),\n      links: changedLinks.concat(addedLinks).concat(removedLinks)\n    };\n  }\n  function getClosestAncestor(node, stateWithNode, stateWithoutNode) {\n    let oldParent = node;\n    while (oldParent) {\n      let newParent = stateWithoutNode.nodes.find(n => areNodesSame(oldParent, n));\n      if (newParent) {\n        return newParent;\n      }\n      oldParent = stateWithNode.nodes.find(n => (props.getChildren(n) || []).some(c => areNodesSame(oldParent, c)));\n    }\n    return stateWithoutNode.nodes[0];\n  }\n  function areNodesSame(a, b) {\n    return a.data[props.keyProp] === b.data[props.keyProp];\n  }\n  function areLinksSame(a, b) {\n    return a.source.data[props.keyProp] === b.source.data[props.keyProp] && a.target.data[props.keyProp] === b.target.data[props.keyProp];\n  }\n  function calculateNewState(animationContext, interval) {\n    return {\n      nodes: animationContext.nodes.map(n => calculateNodePosition(n.base, n.old, n.new, interval)),\n      links: animationContext.links.map(l => calculateLinkPosition(l.base, l.old, l.new, interval))\n    };\n  }\n  function calculateLinkPosition(link, start, end, interval) {\n    return {\n      source: _objectSpread(_objectSpread({}, link.source), {}, {\n        x: calculateNewValue(start.source ? start.source.x : start.x, end.source ? end.source.x : end.x, interval),\n        y: calculateNewValue(start.source ? start.source.y : start.y, end.source ? end.source.y : end.y, interval)\n      }),\n      target: _objectSpread(_objectSpread({}, link.target), {}, {\n        x: calculateNewValue(start.target ? start.target.x : start.x, end.target ? end.target.x : end.x, interval),\n        y: calculateNewValue(start.target ? start.target.y : start.y, end.target ? end.target.y : end.y, interval)\n      })\n    };\n  }\n  function calculateNodePosition(node, start, end, interval) {\n    return _objectSpread(_objectSpread({}, node), {}, {\n      x: calculateNewValue(start.x, end.x, interval),\n      y: calculateNewValue(start.y, end.y, interval)\n    });\n  }\n  function calculateNewValue(start, end, interval) {\n    return start + (end - start) * props.easing(interval);\n  }\n  return /*#__PURE__*/React.createElement(Container, _extends({}, props, state));\n}\nexport { Animated as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}